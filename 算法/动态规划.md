# 动态规划

我们先来思考下面这个问题

> 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。
> 每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？



任何一算法问题几乎都可以使用**暴力破解方式**解答，但是这个方式不是我们想要的，我们来分析一下这个问题，可以得到如下结论：

```
 F(1) = 1;
 F(2) = 2;
 F(n) = F(n-1)+F(n-2)（n>=3）
```

是否似曾相识？根据公式我们可以得出如下解法：

## 方法一：递归求解

```java
int getClimbingWays(int n){
    
    if ( n<1 ) {
        return 0;
    }

    if ( n==1 ) {
        return 1;
    }

    if (n == 2) {
        return 2;
    }
    
    return getClimbingWays(n-1) + getClimbingWays(n-2);
}
```

递归求解可以完成。但是时间复杂度是多少？有没有其他方案？

我们继续分析一下求解过程

![求解过程图](https://github.com/BrooksWon/wby/blob/master/%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92.png)

从上图可以看出颜色相同的色块是重复计算的部分，对于重复计算的情况，应该怎么避免呢？

可以将不同参数的计算结果存在【哈希表】里，遇到相同的参数时，直接从表中取出，不再重复计算了。

这种暂存计算结果的方式有个名字叫：【备忘录算法】

## 方法二：备忘录算法

```java
int getClimbingWays(int n, HashMap<Integer, Integer>map){

    if ( n<1 ) {
        return 0;
    }

    if ( n==1 ) {
        return 1;
    }
    
    if (n == 2) {
        return 2;
    }  

    if (map.containsKey(n)) {
        return map.get(n);
    }else {
        int value = getClimbingWays(n-1, map) + getClimbingWays(n-2, map);
        map.put(n, value);
        
        return value;
    }    
}
```

上面算法的时间复杂度是多少？还有优化的空间吗？

为了进一步优化，我们引入本次的主题**动态规划**

## 动态规划

动态规划(dynamic programming)是运筹学的一个分支，是求解决策过程(decision process)最优化的数学方法。20世纪50年代初美国数学家R.E.Bellman等人在研究多阶段决策过程(multistep decision process)的优化问题时，提出了著名的最优化原理(principle of optimality)，把多阶段过程转化为一系列单阶段问题，利用各阶段之间的关系，逐个求解，创立了解决这类过程优化问题的新方法——动态规划。1957年出版了他的名著《Dynamic Programming》，这是该领域的第一本著作。 

 动态规划（英语：Dynamic programming，简称DP）是一种在数学、管理科学、计算机科学、经济学和生物信息学中使用的，通过把原问题分解为相对简单的子问题的方式求解复杂问题的方法。 

 动态规划常常适用于有重叠子问题[1]和最优子结构性质的问题，动态规划方法所耗时间往往远少于朴素解法。

 动态规划背后的基本思想非常简单。大致上，若要解一个给定问题，我们需要解其不同部分（即子问题），再根据子问题的解以得出原问题的解。

 通常许多子问题非常相似，为此动态规划法试图仅仅解决每个子问题一次，从而减少计算量：一旦某个给定子问题的解已经算出，则将其记忆化存储，以便下次需要同一个子问题解之时直接查表。这种做法在重复子问题的数目关于输入的规模呈指數增長时特别有用。

### 动态规划核心知识点

动态规划包含三个重要概念：最优子结构、边界、状态转移公式。

上述例子中

```
F(1) = 1;
F(2) = 2;
F(n) = F(n-1)+F(n-2)（n>=3）

———————————————-
1.F(10) = F(9)+F(8)，其中F(9)、F(8)是F(10)的最优子结构；

2.F(1) 和 F(2)是问题的边界；

3.F(n) = F(n-1)+F(n-2)是阶段与阶段之间的【状态转移方程】，决定了每个阶段和下个阶段的关系。
```

上面的2中解法都是理由递归的思想，自上而下求解；如果我们按照动态规划的思想，自低而上求解的话是否可以实现呢？直接看代码吧。

## 方法三：动态规划

```java
int getClimbingWays(int n){
    
    if ( n<1 ) {
        return 0;
    }
    
    if ( n==1 ) {
        return 1;
    }
    
    if (n == 2) {
        return 2;
    }
    
    int a = 1;
    int b = 2;
    int temp = 0;
    
    for (int i = 3; i <= n; i++) {
        temp = a + b;
        a = b;
        b = temp;
    }
    
    return temp;
}
```

上面算法的时间复杂度是多少？空间复杂度是多少？

## 总结

动态规划利用简洁的自底向上的递推方式，实现了时间和空间上的最优化。

动态规划包含三个重要概念：最优子结构、边界、状态转移公式。

核心思想就是一句话：大事化小、小事化了；从小处着手、解决大问题。



*通过下面附加题巩固一下对动态算法的掌握程度吧*

>  你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。
>
>  给定一个代表每个房屋存放金额的非负整数数组，计算你在不触动警报装置的情况下，能够偷窃到的最高金额。

